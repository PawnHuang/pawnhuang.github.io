<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pawnhuang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言现在在实现异步时，基本都是使用线程池来实现，线程池在工作应用的还是比较频繁的，本文将就线程池的使用、相关原理和主要方法源码进行深入讲解学习。">
<meta property="og:type" content="article">
<meta property="og:title" content="ThreadPoolExecutor">
<meta property="og:url" content="https://pawnhuang.github.io/2021/04/05/ThreadPoolExecutor/index.html">
<meta property="og:site_name" content="Fake it till you make it">
<meta property="og:description" content="前言现在在实现异步时，基本都是使用线程池来实现，线程池在工作应用的还是比较频繁的，本文将就线程池的使用、相关原理和主要方法源码进行深入讲解学习。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-05T05:39:08.000Z">
<meta property="article:modified_time" content="2024-08-28T15:10:57.897Z">
<meta property="article:author" content="Pawn Huang">
<meta property="article:tag" content="线程池">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://pawnhuang.github.io/2021/04/05/ThreadPoolExecutor/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>ThreadPoolExecutor | Fake it till you make it</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Fake it till you make it</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Pawn Huang's Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pawnhuang.github.io/2021/04/05/ThreadPoolExecutor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/upload/avatar.png">
      <meta itemprop="name" content="Pawn Huang">
      <meta itemprop="description" content="一个非典型程序员">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fake it till you make it">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ThreadPoolExecutor
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-05 13:39:08" itemprop="dateCreated datePublished" datetime="2021-04-05T13:39:08+08:00">2021-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-28 23:10:57" itemprop="dateModified" datetime="2024-08-28T23:10:57+08:00">2024-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在在实现异步时，基本都是使用线程池来实现，线程池在工作应用的还是比较频繁的，本文将就线程池的使用、相关原理和主要方法源码进行深入讲解学习。</p>
<span id="more"></span>

<h2 id="线程池的基本使用"><a href="#线程池的基本使用" class="headerlink" title="线程池的基本使用"></a>线程池的基本使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.joonwhee.concurrent;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池的基本使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JoonWhee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年1月21日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个线程池(完整入参): </span></span><br><span class="line"><span class="comment">     * 核心线程数为5 (corePoolSize), </span></span><br><span class="line"><span class="comment">     * 最大线程数为10 (maximumPoolSize), </span></span><br><span class="line"><span class="comment">     * 存活时间为60分钟(keepAliveTime), </span></span><br><span class="line"><span class="comment">     * 工作队列为LinkedBlockingQueue (workQueue),</span></span><br><span class="line"><span class="comment">     * 线程工厂为默认的DefaultThreadFactory (threadFactory), </span></span><br><span class="line"><span class="comment">     * 饱和策略(拒绝策略)为AbortPolicy: 抛出异常(handler).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">THREAD_POOL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.MINUTES,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(), Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只有一个线程的线程池 没有超时时间, 工作队列使用无界的LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">singleThreadExecutor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="comment">// private static ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(Executors.defaultThreadFactory());</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有固定线程的线程池(即corePoolSize = maximumPoolSize) 没有超时时间,</span></span><br><span class="line"><span class="comment">     * 工作队列使用无界的LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// private static ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5, Executors.defaultThreadFactory());</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大小不限的线程池 核心线程数为0, 最大线程数为Integer.MAX_VALUE, 存活时间为60秒 该线程池可以无限扩展,</span></span><br><span class="line"><span class="comment">     * 并且当需求降低时会自动收缩, 工作队列使用同步移交SynchronousQueue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">// private static ExecutorService cachedThreadPool = Executors.newCachedThreadPool(Executors.defaultThreadFactory());</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定的延迟之后运行任务, 或者定期执行任务的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// private static ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5, Executors.defaultThreadFactory());</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 例子1: 没有返回结果的异步任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        THREAD_POOL.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">                System.out.println(<span class="string">&quot;没有返回结果的异步任务&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 例子2: 有返回结果的异步任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Future&lt;List&lt;String&gt;&gt; future = THREAD_POOL.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">                List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                result.add(<span class="string">&quot;JoonWhee&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;String&gt; result = future.get(); <span class="comment">// 获取返回结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;有返回结果的异步任务: &quot;</span> + result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 例子3: </span></span><br><span class="line"><span class="comment">         * 有延迟的, 周期性执行异步任务</span></span><br><span class="line"><span class="comment">         * 本例子为: 延迟1秒, 每2秒执行1次</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;this is &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 例子4: FutureTask的使用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Callable&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;JoonWhee&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;      </span><br><span class="line">        FutureTask&lt;String&gt; futureTo = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(task);</span><br><span class="line">        THREAD_POOL.submit(futureTo);</span><br><span class="line">        System.out.println(futureTo.get()); <span class="comment">// 获取返回结果</span></span><br><span class="line"><span class="comment">//        System.out.println(futureTo.get(3, TimeUnit.SECONDS));  // 超时时间为3秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="线程池的定义和优点"><a href="#线程池的定义和优点" class="headerlink" title="线程池的定义和优点"></a>线程池的定义和优点</h2><p>线程池，从字面含义来看，是指管理一组同构工作线程的资源池。线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。</p>
<p>“在线程池中执行任务“”比“为每个线程分配一个任务”优势更多。通过重用现有的线程而不是创建线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。通过适当的调整线程池的大小，可以创建足够的线程以便使处理器保持忙碌状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。</p>
<h2 id="线程池工作流程"><a href="#线程池工作流程" class="headerlink" title="线程池工作流程"></a>线程池工作流程</h2><blockquote>
<p>默认情况下，创建完线程池后并不会立即创建线程, 而是等到有任务提交时才会创建线程来进行处理。（除非调用prestartCoreThread或prestartAllCoreThreads方法） <br>当线程数小于核心线程数时，每提交一个任务就创建一个线程来执行，即使当前有线程处于空闲状态，直到当前线程数达到核心线程数。  <br>当前线程数达到核心线程数时，如果这个时候还提交任务，这些任务会被放到队列里，等到线程处理完了手头的任务后，会来队列中取任务处理。  <br>当前线程数达到核心线程数并且队列也满了，如果这个时候还提交任务，则会继续创建线程来处理，直到线程数达到最大线程数。<br>当前线程数达到最大线程数并且队列也满了，如果这个时候还提交任务，则会触发饱和策略。 <br>如果某个线程的控线时间超过了keepAliveTime，那么将被标记为可回收的，并且当前线程池的当前大小超过了核心线程数时，这个线程将被终止。</p>
</blockquote>
<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p>如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将累积起来。在线程池中，这些请求会在一个由Executor管理的Runnable队列中等待，而不会像线程那样去竞争CPU资源。常见的工作队列有以下几种，前三种用的最多。</p>
<blockquote>
<p>ArrayBlockingQueue：列表形式的工作队列，必须要有初始队列大小，有界队列，先进先出。<br> LinkedBlockingQueue：链表形式的工作队列，可以选择设置初始队列大小，有界/无界队列，先进先出。<br> SynchronousQueue：SynchronousQueue不是一个真正的队列，而是一种在线程之间移交的机制。要将一个元素放入SynchronousQueue中, 必须有另一个线程正在等待接受这个元素. 如果没有线程等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutor将创建 一个线程, 否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，因为任务会直接移交 给执行它的线程，而不是被首先放在队列中, 然后由工作者线程从队列中提取任务. 只有当线程池是无界的或者可以拒绝任务时，SynchronousQueue才有实际价值.<br> PriorityBlockingQueue：优先级队列，无界队列，根据优先级来安排任务，任务的优先级是通过自然顺序或Comparator（如果任务实现了Comparator）来定义的。<br> DelayedWorkQueue：延迟的工作队列，无界队列。</p>
</blockquote>
<h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>当有界队列被填满后，饱和策略开始发挥作用。ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改。（如果某个任务被提交到一个已被关闭的Executor时，也会用到饱和策略）。饱和策略有以下四种，一般使用默认的AbortPolicy。</p>
<blockquote>
<p>AbortPolicy：中止策略。默认的饱和策略，抛出未检查的RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。<br> DiscardPolicy：抛弃策略。当新提交的任务无法保存到队列中等待执行时，该策略会悄悄抛弃该任务。<br> DiscardOldestPolicy：抛弃最旧的策略。当新提交的任务无法保存到队列中等待执行时，则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”策略和优先级队列放在一起使用）。<br> CallerRunsPolicy：调用者运行策略。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者（调用线程池执行任务的主线程），从而降低新任务的流程。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。当线程池的所有线程都被占用，并且工作队列被填满后，下一个任务会在调用execute时在主线程中执行（调用线程池执行任务的主线程）。由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得工作者线程有时间来处理完正在执行的任务。在这期间，主线程不会调用accept，因此到达的请求将被保存在TCP层的队列中。如果持续过载，那么TCP层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载后，这种过载情况会逐渐向外蔓延开来——从线程池到工作队列到应用程序再到TCP层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。</p>
</blockquote>
<h2 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h2><p>每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。在ThreadFactory中只定义了一个方法newThread，每当线程池需要创建一个新线程时都会调用这个方法。Executors提供的线程工厂有两种，一般使用默认的，当然如果有特殊需求，也可以自己定制。</p>
<blockquote>
<p>DefaultThreadFactory：默认线程工厂，创建一个新的、非守护的线程，并且不包含特殊的配置信息。<br> PrivilegedThreadFactory：通过这种方式创建出来的线程，将与创建privilegedThreadFactory的线程拥有相同的访问权限、 AccessControlContext、ContextClassLoader。如果不使用privilegedThreadFactory， 线程池创建的线程将从在需要新线程时调用execute或submit的客户程序中继承访问权限。<br> 自定义线程工厂：可以自己实现ThreadFactory接口来定制自己的线程工厂方法。</p>
</blockquote>
<h2 id="ThreadPoolExecutor源码解析"><a href="#ThreadPoolExecutor源码解析" class="headerlink" title="ThreadPoolExecutor源码解析"></a>ThreadPoolExecutor源码解析</h2><h3 id="几个点"><a href="#几个点" class="headerlink" title="几个点"></a>几个点</h3><p>了解这几个点，有助于你阅读下面的源码解释。</p>
<blockquote>
<p>下面的源码解读中提到的运行状态就是runState，有效的线程数就是workerCount，内容比较多，所以可能两种写法都用到。<br> 运行状态的一些定义：RUNNING：接受新任务并处理排队任务； SHUTDOWN：不接受新任务，但处理排队任务； STOP：不接受新任务，不处理排队任务，并中断正在进行的任务；TIDYING：所有任务已经终止，workerCount为零，线程转换到状态TIDYING将运行terminate()钩子方法；TERMINATED：terminated()已经完成，该方法执行完毕代表线程池已经完全终止。<br> 运行状态之间并不是随意转换的，大多数状态都只能由固定的状态转换而来，转换关系见下。<br> RUNNING - &gt; SHUTDOWN：在调用shutdown()时，可能隐含在finalize()。<br> (RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()。<br> SHUTDOWN - &gt; TIDYING：当队列和线程池都是空的时。<br> STOP - &gt; TIDYING：当线程池为空时。<br> TIDYING - &gt; TERMINATED：当terminate()方法完成时。</p>
</blockquote>
<h3 id="基础属性（很重要）"><a href="#基础属性（很重要）" class="headerlink" title="基础属性（很重要）"></a>基础属性（很重要）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主池控制状态ctl是包含两个概念字段的原子整数: workerCount：指有效的线程数量；</span></span><br><span class="line"><span class="comment"> * runState：指运行状态，运行，关闭等。为了将workerCount和runState用1个int来表示，</span></span><br><span class="line"><span class="comment"> * 我们限制workerCount范围为(2 ^ 29) - 1，即用int的低29位用来表示workerCount，</span></span><br><span class="line"><span class="comment"> * 用int的高3位用来表示runState，这样workerCount和runState刚好用int可以完整表示。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 初始化时有效的线程数为0, 此时ctl为: 1010 0000 0000 0000 0000 0000 0000 0000 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>)); </span><br><span class="line"><span class="comment">// 高3位用来表示运行状态，此值用于运行状态向左移动的位数，即29位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;     </span><br><span class="line"><span class="comment">// 线程数容量，低29位表示有效的线程数, 0001 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大小关系：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED，</span></span><br><span class="line"><span class="comment"> * 源码中频繁使用大小关系来作为条件判断。</span></span><br><span class="line"><span class="comment"> * 1110 0000 0000 0000 0000 0000 0000 0000 运行</span></span><br><span class="line"><span class="comment"> * 0000 0000 0000 0000 0000 0000 0000 0000 关闭</span></span><br><span class="line"><span class="comment"> * 0010 0000 0000 0000 0000 0000 0000 0000 停止</span></span><br><span class="line"><span class="comment"> * 0100 0000 0000 0000 0000 0000 0000 0000 整理</span></span><br><span class="line"><span class="comment"> * 0110 0000 0000 0000 0000 0000 0000 0000 终止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 运行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">// 关闭</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 停止</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">// 整理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">// 终止</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到运行状态:入参c为ctl的值，~CAPACITY高3位为1低29位全为0, </span></span><br><span class="line"><span class="comment"> * 因此运算结果为ctl的高3位, 也就是运行状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到有效的线程数:入参c为ctl的值, CAPACITY高3为为0, </span></span><br><span class="line"><span class="comment"> * 低29位全为1, 因此运算结果为ctl的低29位, 也就是有效的线程数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到ctl的值：高3位的运行状态和低29位的有效线程数进行或运算, </span></span><br><span class="line"><span class="comment"> * 组合成一个完成的32位数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;    </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 状态c是否小于s</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateLessThan</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 状态c是否大于等于s</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateAtLeast</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 状态c是否为RUNNING（小于SHUTDOWN的状态只有RUNNING）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用CAS增加一个有效的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndIncrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;    </span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用CAS减少一个有效的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndDecrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;    </span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 减少一个有效的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">decrementWorkerCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 工作队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;    </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 包含线程池中的所有工作线程,只有在mainLock的情况下才能访问,Worker集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">termination</span> <span class="operator">=</span> mainLock.newCondition();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 跟踪线程池的最大到达大小，仅在mainLock下访问</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 总的完成的任务数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> completedTaskCount;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 线程工厂，用于创建线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程超时时间，当线程数超过corePoolSize时生效, </span></span><br><span class="line"><span class="comment"> * 如果有线程空闲时间超过keepAliveTime, 则会被终止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;    </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 是否允许核心线程超时，默认false，false情况下核心线程会一直存活。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 核心线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 默认饱和策略（拒绝策略）, 抛异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RuntimePermission</span> <span class="variable">shutdownPerm</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;modifyThread&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Worker类，每个Worker包含一个线程、一个初始任务、一个任务计算器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span>   </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6138294804551838833L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> Thread thread;    <span class="comment">// Worker对应的线程</span></span><br><span class="line">    Runnable firstTask; <span class="comment">// 运行的初始任务。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;   <span class="comment">// 每个线程的任务计数器</span></span><br><span class="line"> </span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// 禁止中断，直到runWorker</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask; <span class="comment">// 设置为初始任务</span></span><br><span class="line">        <span class="comment">// 使用当前线程池的线程工厂创建一个线程</span></span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);  </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将主运行循环委托给外部runWorker</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过AQS的同步状态来实现锁机制。state为0时代表锁未被获取（解锁状态），</span></span><br><span class="line"><span class="comment">     * state为1时代表锁已经被获取（加锁状态）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123; <span class="comment">// </span></span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> &#123;  <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123; <span class="comment">// 使用CAS尝试将state设置为1，即尝试获取锁</span></span><br><span class="line">            <span class="comment">// 成功将state设置为1，则当前线程拥有独占访问权</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());    </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> &#123;  <span class="comment">// 尝试释放锁</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);  <span class="comment">// 释放独占访问权：即将独占访问线程设为null</span></span><br><span class="line">        setState(<span class="number">0</span>);    <span class="comment">// 解锁：将state设置为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>        &#123; acquire(<span class="number">1</span>); &#125;   <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>  &#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125; <span class="comment">// 尝试加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>      &#123; release(<span class="number">1</span>); &#125;   <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123; <span class="keyword">return</span> isHeldExclusively(); &#125;  <span class="comment">// 是否为加锁状态 </span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">interruptIfStarted</span><span class="params">()</span> &#123; <span class="comment">// 如果线程启动了，则进行中断</span></span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h3><p>使用线程池的submit方法提交任务时，会走到该方法，该方法也是线程池最重要的方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Runnable command</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)    <span class="comment">// 为空校验</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">int</span> c = ctl.<span class="keyword">get</span>();  <span class="comment">// 拿到当前的ctl值</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  <span class="comment">// 如果有效的线程数小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))   <span class="comment">// 则新建一个线程来处理任务（核心线程）</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.<span class="keyword">get</span>();  <span class="comment">// 拿到当前的ctl值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里说明有效的线程数已经 &gt;= 核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<span class="comment">// 如果当前状态是运行, 尝试将任务放入工作队列</span></span><br><span class="line">        <span class="built_in">int</span> recheck = ctl.<span class="keyword">get</span>();    <span class="comment">// 再次拿到当前的ctl值</span></span><br><span class="line">        <span class="comment">// 如果再次检查状态不是运行, 则将刚才添加到工作队列的任务移除</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; <span class="keyword">remove</span>(command)) </span><br><span class="line">            reject(command);    <span class="comment">// 并调用拒绝策略</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) <span class="comment">// 如果再次检查时,有效的线程数为0, </span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>); <span class="comment">// 则新建一个线程(非核心线程)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里说明工作队列已满</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))<span class="comment">//尝试新建一个线程来处理任务(非核心)</span></span><br><span class="line">        reject(command);    <span class="comment">// 如果失败则调用拒绝策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法就是对应上文的线程池的工作流程。主要调用到的方法为addWorker（见下文addWorker方法解读）。</p>
<h3 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一个Worker，Worker包含一个线程和一个任务，由这个线程来执行该任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">boolean</span> addWorker(Runnable firstTask, <span class="built_in">boolean</span> core) &#123;   </span><br><span class="line">    <span class="keyword">retry</span>:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">int</span> c = ctl.get();  <span class="comment">// c赋值为ctl</span></span><br><span class="line">        <span class="built_in">int</span> rs = runStateOf(c); <span class="comment">// rs赋值为运行状态</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.如果池停止或有资格关闭，则此方法返回false；</span></span><br><span class="line"><span class="comment">         * 如果线程工厂在被询问时未能创建线程，它也返回false。 </span></span><br><span class="line"><span class="comment">         * 包括以下5种情况：</span></span><br><span class="line"><span class="comment">         * 1).rs为RUNNING，通过校验。</span></span><br><span class="line"><span class="comment">         * 2).rs为STOP或TIDYING或TERMINATED，返回false。</span></span><br><span class="line"><span class="comment">         * （STOP、TIDYING、TERMINATED：已经停止进入最后清理终止，不接受任务不处理队列任务）</span></span><br><span class="line"><span class="comment">         * 3).rs为SHUTDOWN，提交的任务不为空，返回false。</span></span><br><span class="line"><span class="comment">         * （SHUTDOWN：不接受任务但是处理队列任务，因此任务不为空返回false）</span></span><br><span class="line"><span class="comment">         * 4).rs为SHUTDOWN，提交的任务为空，并且工作队列为空，返回false。</span></span><br><span class="line"><span class="comment">         * （状态为SHUTDOWN、提交的任务为空、工作队列为空，则线程池有资格关闭，直接返回false）</span></span><br><span class="line"><span class="comment">         * 5).rs为SHUTDOWN，提交的任务为空，并且工作队列不为空，通过校验。</span></span><br><span class="line"><span class="comment">         * （因为SHUTDOWN状态下刚好可以处理队列任务）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="built_in">int</span> wc = workerCountOf(c);  <span class="comment">// 拿到有效的线程数</span></span><br><span class="line">            <span class="comment">// 校验有效的线程数是否超过阈值</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 使用CAS将workerCount+1, 修改成功则跳出循环，否则进入下面的状态判断</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> <span class="keyword">retry</span>;</span><br><span class="line">            c = ctl.get();  <span class="comment">// 重新读取ctl</span></span><br><span class="line">            <span class="comment">// 判断当前运行状态，如果不等于上面获取的运行状态rs，</span></span><br><span class="line">            <span class="comment">// 说明rs被其他线程修改了，跳到retry重新校验线程池状态</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> <span class="keyword">retry</span>;</span><br><span class="line">            <span class="comment">// 走到这里说明compareAndIncrementWorkerCount失败; </span></span><br><span class="line">            <span class="comment">// 重试内部循环（状态没变，则继续内部循环，尝试使用CAS修改workerCount）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">boolean</span> workerStarted = <span class="literal">false</span>;  <span class="comment">// Worker的线程是否启动</span></span><br><span class="line">    <span class="built_in">boolean</span> workerAdded = <span class="literal">false</span>;    <span class="comment">// Worker是否成功增加</span></span><br><span class="line">    Worker w = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);  <span class="comment">// 用firstTask和当前线程创建一个Worker</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;  <span class="comment">// 拿到Worker对应的线程</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();    <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="built_in">int</span> rs = runStateOf(ctl.get()); <span class="comment">// 加锁的情况下重新获取当前的运行状态</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 如果当前的运行状态为RUNNING，</span></span><br><span class="line">                <span class="comment">// 或者当前的运行状态为SHUTDOWN并且firstTask为空，则通过校验</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())    <span class="comment">// 预先校验线程是可以启动的</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w); <span class="comment">// 将刚创建的worker添加到工作者列表</span></span><br><span class="line">                    <span class="built_in">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;  <span class="comment">// 如果Worker添加成功，则启动线程执行</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)    <span class="comment">// 如果Worker的线程没有成功启动</span></span><br><span class="line">            addWorkerFailed(w); <span class="comment">// 则进行回滚, 移除之前添加的Worker</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要目的就是使用入参中的firstTask和当前线程添加一个Worker，前面的for循环主要是对当前线程池的运行状态和有效的线程数进行一些校验，校验逻辑比较绕，可以参考注释进行理解。该方法涉及到的其他方法有addWorkerFailed（见下文addWorkerFailed源码解读）；还有就是Worker的线程启动时，会调用Worker里的run方法，执行runWorker(this)方法（见下文runWorker源码解读）。</p>
<h3 id="addWorkerFailed方法"><a href="#addWorkerFailed方法" class="headerlink" title="addWorkerFailed方法"></a>addWorkerFailed方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rolls back the worker thread creation.</span></span><br><span class="line"><span class="comment"> * - removes worker from workers, if present</span></span><br><span class="line"><span class="comment"> * - decrements worker count</span></span><br><span class="line"><span class="comment"> * - rechecks for termination, in case the existence of this</span></span><br><span class="line"><span class="comment"> *   worker was holding up termination</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span>(<span class="params">Worker w</span>)</span> &#123;    <span class="comment">// 回滚Worker的添加，就是将Worker移除</span></span><br><span class="line">    final ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">            workers.<span class="keyword">remove</span>(w);  <span class="comment">// 移除Worker</span></span><br><span class="line">        decrementWorkerCount(); <span class="comment">// 有效线程数-1</span></span><br><span class="line">        tryTerminate(); <span class="comment">// 有worker线程移除，可能是最后一个线程退出需要尝试终止线程池</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法很简单，就是移除入参中的Worker并将workerCount-1，最后调用tryTerminate尝试终止线程池，tryTerminate见下文对应方法源码解读。</p>
<h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><p>上文addWork方法里说道，当Worker里的线程启动时，就会调用该方法。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Worker的线程开始执行任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread(); <span class="comment">// 获取当前线程</span></span><br><span class="line">    Runnable <span class="keyword">task</span> = w.firstTask;    <span class="comment">// 拿到Worker的初始任务</span></span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;   <span class="comment">// Worker是不是因异常而死亡</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">task</span> != <span class="keyword">null</span> || (<span class="keyword">task</span> = getTask()) != <span class="keyword">null</span>) &#123;<span class="comment">// Worker取任务执行</span></span><br><span class="line">            w.lock();   <span class="comment">// 加锁</span></span><br><span class="line">            <span class="comment">/**如果线程池停止，确保线程中断; 如果不是，确保线程不被中断。</span></span><br><span class="line"><span class="comment">             * 在第二种情况下进行重新检查，以便在清除中断的同时处理shutdownNow竞争</span></span><br><span class="line"><span class="comment">             * 线程池停止指运行状态为STOP/TIDYING/TERMINATED中的一种</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||    <span class="comment">// 判断线程池运行状态</span></span><br><span class="line">                 (Thread.interrupted() &amp;&amp;   <span class="comment">// 重新检查</span></span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp; <span class="comment">// 再次判断线程池运行状态</span></span><br><span class="line">                !wt.isInterrupted())<span class="comment">// 走到这里代表线程池运行状态为停止,检查wt是否中断</span></span><br><span class="line">                wt.interrupt(); <span class="comment">// 线程池的状态为停止并且wt不为中断, 则将wt中断</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, <span class="keyword">task</span>);<span class="comment">// 执行beforeExecute（默认空，需要自己重写）</span></span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">task</span>.run(); <span class="comment">// 执行任务</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x; <span class="comment">//如果抛异常,则completedAbruptly为true</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(<span class="keyword">task</span>, thrown);<span class="comment">// 执行afterExecute（需要自己重写）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">task</span> = <span class="keyword">null</span>;    <span class="comment">// 将执行完的任务清空</span></span><br><span class="line">                w.completedTasks++; <span class="comment">// Worker完成任务数+1</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;  <span class="comment">// 如果执行到这里，则worker是正常退出</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);<span class="comment">// 调用processWorkerExit方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法为Worker线程开始执行任务，首先执行当初创建Worker时的初始任务，接着从工作队列中获取任务执行。主要涉及两个方法：获取任务的方法getTask（见下文getTask源码解读）和执行Worker退出的方法processWorkerExit（见下文processWorkerExit源码解读）。注：processWorkerExit在处理正常Worker退出时，没有对workerCount-1，而是在getTask方法中进行workerCount-1。</p>
<h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;    <span class="comment">// Worker从工作队列获取任务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// poll方法取任务是否超时</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 无线循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();  <span class="comment">// ctl</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c); <span class="comment">// 当前运行状态</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果线程池运行状态为停止，或者可以停止（状态为SHUTDOWN并且队列为空）</span></span><br><span class="line">        <span class="comment">// 则返回null，代表当前Worker需要移除</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;    </span><br><span class="line">            decrementWorkerCount(); <span class="comment">// 将workerCount - 1</span></span><br><span class="line">            <span class="comment">// 返回null前将workerCount - 1,</span></span><br><span class="line">            <span class="comment">// 因此processWorkerExit中completedAbruptly＝false时无需再减</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);  <span class="comment">// 当前的workerCount</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 判断当前Worker是否可以被移除, 即当前Worker是否可以一直等待任务。</span></span><br><span class="line">        <span class="comment">// 如果allowCoreThreadTimeOut为true，或者workerCount大于核心线程数，</span></span><br><span class="line">        <span class="comment">// 则当前线程是有超时时间的（keepAliveTime），无法一直等待任务。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;    </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果wc超过最大线程数 或者 当前线程会超时并且已经超时，</span></span><br><span class="line">        <span class="comment">// 并且wc &gt; 1 或者 工作队列为空，则返回null，代表当前Worker需要移除</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;   <span class="comment">// 确保有Worker可以移除 </span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="comment">// 返回null前将workerCount - 1，</span></span><br><span class="line">                <span class="comment">// 因此processWorkerExit中completedAbruptly＝false时无需再减</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据线程是否会超时调用相应的方法，poll为带超时的获取任务方法</span></span><br><span class="line">            <span class="comment">// take()为不带超时的获取任务方法，会一直阻塞直到获取到任务</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ? </span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;    <span class="comment">// 走到这代表当前线程获取任务超时</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>;   <span class="comment">// 被中断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Worker从工作队列获取任务，如果allowCoreThreadTimeOut为false并且  workerCount&lt;=corePoolSize，则这些核心线程永远存活，并且一直在尝试获取工作队列的任务；否则，线程会有超时时间（keepAliveTime），当在keepAliveTime时间内获取不到任务，该线程的Worker会被移除。 <br>Worker移除的过程：getTask方法返回null，导致runWorker方法中跳出while循环，调用processWorkerExit方法将Worker移除。注意：在返回null的之前，已经将workerCount-1，因此在processWorkerExit中，completedAbruptly=false的情况（即正常超时退出）不需要再将workerCount-1。</p>
<h3 id="processWorkerExit方法"><a href="#processWorkerExit方法" class="headerlink" title="processWorkerExit方法"></a>processWorkerExit方法</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span>(Worker w, <span class="type">boolean</span> completedAbruptly) &#123;   <span class="comment">// Worker的退出</span></span><br><span class="line">    <span class="comment">// 如果Worker是异常死亡（completedAbruptly=true），则workerCount-1；</span></span><br><span class="line">    <span class="comment">// 如果completedAbruptly为false的时候（正常超时退出），则代表task=getTask()等于null，</span></span><br><span class="line">    <span class="comment">// getTask()方法中返回null的地方，都已经将workerCount - 1，所以此处无需再-1</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) </span><br><span class="line">        <span class="title function_">decrementWorkerCount</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="variable">this</span>.<span class="property">mainLock</span>;</span><br><span class="line">    mainLock.<span class="property">lock</span>();    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.<span class="property">completedTasks</span>; <span class="comment">// 该Worker完成的任务数加到总完成的任务数</span></span><br><span class="line">        workers.<span class="property">remove</span>(w);  <span class="comment">// 移除该Worker</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.<span class="property">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">tryTerminate</span>(); <span class="comment">// 有Worker线程移除，可能是最后一个线程退出，需要尝试终止线程池</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> c = ctl.<span class="property">get</span>();  <span class="comment">// 获取当前的ctl</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">runStateLessThan</span>(c, STOP)) &#123;  <span class="comment">// 如果线程池的运行状态还没停止（RUNNING或SHUTDOWN）</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;   <span class="comment">// 如果Worker不是异常死亡</span></span><br><span class="line">            <span class="comment">// min为线程池的理论最小线程数:如果允许核心线程超时则min为0,否则min为核心线程数</span></span><br><span class="line">            <span class="type">int</span> <span class="built_in">min</span> = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;    </span><br><span class="line">            <span class="comment">// 如果min为0,工作队列不为空,将min设置为1,确保至少有1个Worker来处理队列里的任务 </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">min</span> == <span class="number">0</span> &amp;&amp; ! workQueue.<span class="property">isEmpty</span>())</span><br><span class="line">                <span class="built_in">min</span> = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 当前有效的线程数&gt;=min，直接返回;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">workerCountOf</span>(c) &gt;= <span class="built_in">min</span>)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed </span></span><br><span class="line">            <span class="comment">// 如果代码走到这边，代表workerCountOf(c) &lt; min，此时会走到下面的addWorker方法。</span></span><br><span class="line">            <span class="comment">// 通过getTask方法我们知道，当allowCoreThreadTimeOut为false</span></span><br><span class="line">            <span class="comment">// 并且workerCount&lt;=corePoolSize时，是不会走到processWorkerExit方法的。</span></span><br><span class="line">            <span class="comment">// 因此走到这边只可能是当前移除的Worker是最后一个Worker，但是此时工作</span></span><br><span class="line">            <span class="comment">// 队列还不为空，因此min被设置成了1，所以需要在添加一个Worker来处理工作队列。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">addWorker</span>(<span class="literal">null</span>, <span class="literal">false</span>); <span class="comment">// 添加一个Worker</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法就是执行Worker的退出：统计完成的任务数，将Worker移除，并尝试终止线程池，最后根据情况决定是否创建一个新的Worker。两种情况下会创建一个新的Worker：1）被移除的Worker是由于异常而死亡；2）被移除的Worker是最后一个Worker，但是工作队列还有任务。completedAbruptly=false时，没有将workerCount-1是因为已经在getTask方法中将workerCount-1。</p>
<h3 id="tryTerminate方法"><a href="#tryTerminate方法" class="headerlink" title="tryTerminate方法"></a>tryTerminate方法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> void tryTerminate() &#123; <span class="comment">// 尝试终止线程池</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        int c = ctl.<span class="keyword">get</span>();</span><br><span class="line">        <span class="comment">// 只有当前状态为STOP 或者 SHUTDOWN并且队列为空，才会尝试整理并终止</span></span><br><span class="line">        <span class="comment">// 1: 当前状态为RUNNING，则不尝试终止，直接返回</span></span><br><span class="line">        <span class="comment">// 2: 当前状态为TIDYING或TERMINATED，代表有其他线程正在执行终止，直接返回</span></span><br><span class="line">        <span class="comment">// 3: 当前状态为SHUTDOWN 并且 workQueue不为空，则不尝试终止，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) || <span class="comment">// 1</span></span><br><span class="line">            runStateAtLeast(c, TIDYING) ||  <span class="comment">// 2</span></span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))   <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 走到这代表线程池可以终止（通过上面的校验）</span></span><br><span class="line">        <span class="comment">// 如果此时有效线程数不为0， 将中断一个空闲的Worker，以确保关闭信号传播</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate </span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();    <span class="comment">// 加锁，终止线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用CAS将ctl的运行状态设置为TIDYING，有效线程数设置为0</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();   <span class="comment">// 供用户重写的terminated方法，默认为空</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 将ctl的运行状态设置为TERMINATED，有效线程数设置为0</span></span><br><span class="line">                    ctl.<span class="keyword">set</span>(ctlOf(TERMINATED, <span class="number">0</span>));  </span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法用来尝试终止线程池，主要在移除Worker后会调用此方法。首先进行一些状态的校验，如果通过校验，则在加锁的条件下，使用CAS将运行状态设为TERMINATED，有效线程数设为0。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本文完全参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/v123411739/article/details/79124193">https://blog.csdn.net/v123411739/article/details/79124193</a><br>不含一点原创知识，奥里给</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag"># 线程池</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/jdk1-8-%E9%87%8C%E7%9A%84-HashMap/" rel="prev" title="jdk1.8 里的 HashMap">
      <i class="fa fa-chevron-left"></i> jdk1.8 里的 HashMap
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/07/Mysql/" rel="next" title="Mysql">
      Mysql <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">线程池的基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%98%E7%82%B9"><span class="nav-number">3.</span> <span class="nav-text">线程池的定义和优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">线程池工作流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">工作队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">6.</span> <span class="nav-text">拒绝策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%8E%82"><span class="nav-number">7.</span> <span class="nav-text">线程工厂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">8.</span> <span class="nav-text">ThreadPoolExecutor源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E4%B8%AA%E7%82%B9"><span class="nav-number">8.1.</span> <span class="nav-text">几个点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7%EF%BC%88%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">8.2.</span> <span class="nav-text">基础属性（很重要）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execute%E6%96%B9%E6%B3%95"><span class="nav-number">8.3.</span> <span class="nav-text">execute方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#addWorker%E6%96%B9%E6%B3%95"><span class="nav-number">8.4.</span> <span class="nav-text">addWorker方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#addWorkerFailed%E6%96%B9%E6%B3%95"><span class="nav-number">8.5.</span> <span class="nav-text">addWorkerFailed方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runWorker%E6%96%B9%E6%B3%95"><span class="nav-number">8.6.</span> <span class="nav-text">runWorker方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getTask%E6%96%B9%E6%B3%95"><span class="nav-number">8.7.</span> <span class="nav-text">getTask方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#processWorkerExit%E6%96%B9%E6%B3%95"><span class="nav-number">8.8.</span> <span class="nav-text">processWorkerExit方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tryTerminate%E6%96%B9%E6%B3%95"><span class="nav-number">8.9.</span> <span class="nav-text">tryTerminate方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">9.</span> <span class="nav-text">注意</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Pawn Huang"
      src="/upload/avatar.png">
  <p class="site-author-name" itemprop="name">Pawn Huang</p>
  <div class="site-description" itemprop="description">一个非典型程序员</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pawn Huang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">181k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:44</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
